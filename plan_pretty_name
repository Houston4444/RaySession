Patchance:
    Si pas de pretty_name en place:
        on applique
    Si pretty_name en place == pretty_name sauvé:
        Ne rien faire
    Si pretty_name existant == pretty_name en dessous:
        on applique

en gros:
    le pretty_name sauvé contient:
        le pretty_name
        le pretty_name précédant si existant

Comportement autoritaire:
    définir systématiquement le pretty_name comme celui sauvé

    Si un pretty_name défini de l'exterieur:
        le remplacer.

    Problème: 2 programmes avec ce comportement créent une boucle infini
              pas cool avec les autres programmes: à éviter !

Comportement dévoreur:
    définir systématiquement le pretty_name comme celui sauvé

    Si un pretty_name défini de l'exterieur:
        remplacer le pretty-name par le sus-défini dans sa base

    Problème: Impossible d'outre-passer la volonté d'un client exterieur,
              le pretty-name sera toujours celui défini de l'exterieur,
              Il faudra le changer à chaque fois : nul !

Comportement mixte actuel:
    définir systématiquement le pretty_name comme celui sauvé sauf si
    le pretty-name existant est défini comme celui qui doit être écrasé
        sinon: ne rien faire

    Si un pretty_name défini de l'exterieur:
        Ne rien faire, il est prioritaire

    Problèmes: 1 ) La session n'est pas vraiment sauvegardée en l'état,
               des pretty-names peuvent ne pas être remis dans la session.
               Des pretty names internes sont affichés dans certaines conditions
               et pas dans d'autres.

               2 ) Comment savoir au chargement que l'on a le droit d'écraser
               tel pretty-name vu que c'est ce programme même qui les a écrits,
               peut-être même lors d'un lancement précédent.

    Solutions: 1 ) peu de chances que ça arrive, et quand bien même c'est pas si grave.
                    ça peut être un peu chiant quand même.
               2 ) Soit:
                    une métadonnée pretty-name-setter
                    une sauvegarde dans /tmp systématique


Comportement mangeur prudent:
    définir systématiquement le pretty_name comme celui sauvé sauf si
    le pretty-name existant est défini comme celui qui doit être écrasé
        sinon: remplacer dans la base

    Si un pretty_name défini de l'exterieur:
        remplace le nouveau pretty_name dans sa base

    Problèmes: On ne sait pas retirer ces pretty-names sans en retirer d'autres.
               Une fausse manip de l'exterieur écrase tout.

    Solutions: On sauve aussi dans la database si la définition est externe.
                au deuxième lancement aucun pretty-name ne pourra être supprimé
                puisqu'ils ont tous été défini de manière externe.

Pour savoir si un pretty name est défini par soi, on peut checker l'apparition de pretty name


Donc:
    Internal pretty name:
        Uniquement les noms définis par l'utilisateur dans l'application !
    Défini/Non_défini config/session:
        Si on change rien, un pretty-name défini restera défini at vitam aeternam,
        et ce n'est pas grave.

    Concurrence entre instances RS et Patchance:
        C'est la grosse merde. Quoique.

        RS démarré avant, patchance après:
            Patchance arrive et 
                ecrit tous les non-définis
                remplace tous les pretty names qui ont un nom à se faire écraser.
            Patchance repart en laissant tout en plan.
                Tout nouveau chg sur les items définis par Patchance ne sera pas effectif
                puisque le pretty_name écrasable aura changé.
                    (pas de solution)
    
    Bouton: définir tous les Jolis noms internes avec les jolis noms JACK
        enabled si des pretty_names JACK existent et sont différent du pretty name interne
    Bouton: redéfinir tous jolis noms JACK avec les jolis noms internes
        enabled si des ports ou groupes JACK ayant un prettyname interne et n'ayant pas de 
        pretty_name JACK ou different.






