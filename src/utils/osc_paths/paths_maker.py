#!/usr/bin/env python3

'''This module updates shared/osc_paths module with contents of all_paths
file present in the same folder.

In `all_paths` file,
Each line starting with '/' is an OSC path.
types can be described after a space in the same line.
Line starting with 4 spaces is part of comment of the previous OSC path.
'''

from pathlib import Path
from collections import defaultdict
import sys
from typing import Optional

HEADER = '''
# This file has been generated by src/utils/osc_paths/path_makers.py.
# Do not edit it, edit 'all_paths' file and run 'path_makers.py'.'''


types_py = {
    's': 'str',
    'i': 'int',
    'h': 'int',
    'f': 'float',
    'b': 'bytes',
    'T': 'bool',
    'F': 'bool',
    '.': 'OscArg'
}


class OscPath:
    def __init__(self, line: str):
        value, _, types = line.partition(' ')
        self.value = value.strip()
        self.types = types.strip()
        self.key = self.value.rpartition('/')[2].upper()
        self.input_comments = ''
    
    def add_comment(self, line: str):
        if self.input_comments:
            self.input_comments += '\n'
        self.input_comments += line.strip()
        
    def export(self) -> str:
        if not self.input_comments and not self.types:
            return f"{self.key} = '{self.value}'"
        
        types_str = ''
        if self.types:
            types_str = f' (arg types: {self.types})'

        if "'" in self.input_comments or '\n' in self.input_comments:
            return (f"{self.key} = '{self.value}'\n"
                    f"'''{self.input_comments}{types_str}'''\n")
        return (f"{self.key} = '{self.value}'\n"
                f"'{self.input_comments}{types_str}'\n")


class FilePrepare:
    def __init__(self):
        self.imports = set[str]()
        self.osc_paths = list[OscPath]()
    
    @property
    def contents(self) -> str:
        imports = '\n'.join([
            f'from . import {m}' for m in sorted(self.imports)])
        defines = '\n'.join([op.export() for op in self.osc_paths])
        return '\n\n'.join([HEADER, imports, defines])


def write_ray_control_pyi(
        path: Path, file_prepare: FilePrepare, name: str):
    out_lines = list[str]()
    out_lines.append('from typing import overload')
    out_lines.append('import osc_paths.ray as r')
    out_lines.append('')
    out_lines.append('def _osc(path: str):...')
    out_lines.append('')
    out_lines.append('')

    if name == 'Client':
        out_lines.append('import client')
        out_lines.append('')
        out_lines.append(f'class {name}:')
        out_lines.append('    client_id: str')
        out_lines.append('')

    for osc_path in file_prepare.osc_paths:
        types_split = osc_path.types.split('|')
        for i, types_spl in enumerate(types_split):
            arg_types = list[str]()
            previous = ''
            for j, l in enumerate(types_spl):
                if l == '*':
                    if previous:
                        arg_types[-1] = f'*args: {types_py[previous]}'
                    else:
                        arg_types.append('*args')
                else:
                    if j == 0:
                        if name in ('client', 'trashed_client'):
                            arg_types.append(f'client_id: str')
                        elif name == 'Client':
                            arg_types.append('self')
                        else:
                            arg_types.append(f'arg_{j+1}: {types_py[l]}')
                    else:
                        arg_types.append(f'arg_{j+1}: {types_py[l]}')

                previous = l
        
            args_str = ', '.join(arg_types)
            
            match osc_path.key.lower().partition('_')[0]:
                case 'list':
                    ret_type = ' -> list[str]'
                case 'get':
                    ret_type = ' -> str'
                case 'add':
                    if osc_path.value.startswith('/ray/session/add_'):
                        ret_type = ' -> str'
                    else:
                        ret_type = ' -> bool'
                case _:
                    ret_type = ' -> bool'
            
            if i == 0:
                out_lines.append(f'@_osc(r.{name.lower()}.{osc_path.key})')

            if '|' in osc_path.types:
                out_lines.append('@overload')
            
            out_lines.append(
                f'def {osc_path.key.lower()}({args_str}){ret_type}:')
            out_lines.append('    ...')

            if i + 1 == len(types_split):
                out_lines.append('')
    
    if name == 'Client':
        out_lines_ = list[str]()
        for i, line in enumerate(out_lines):
            if i < 10:
                out_lines_.append(line)
            else:
                out_lines_.append('    ' + line)
        out_lines = out_lines_
    
    name_pyi = \
        Path(__file__).parents[2] / f'shared/ray_control/{name}.pyi'
    
    with open(name_pyi, 'w') as f:
        f.write('\n'.join(out_lines))


if __name__ == '__main__':
    paths_file = Path(__file__).parent / 'all_paths'

    with open(paths_file, 'r') as f:
        contents = f.read()

    all_paths = contents.splitlines()

    code_root = paths_file.parent
    while code_root.name != 'RaySession':
        code_root = code_root.parent
        if code_root.name == '/':
            print('this file is not in a RaySession folder, exit.')
            sys.exit(1)

    root = code_root / 'src' / 'shared' / 'osc_paths'
    root.mkdir(exist_ok=True)

    file_prepares = defaultdict[Path, FilePrepare](FilePrepare)
    current_osc_path: Optional[OscPath] = None

    for osc_str in all_paths:
        osc_str = osc_str.strip()
        if not osc_str.startswith('/'):
            if current_osc_path is not None:
                current_osc_path.add_comment(osc_str)
            continue

        p = root / osc_str[1:]
        pdir = p.parent

        current_osc_path = OscPath(osc_str)
        file_prepares[pdir].osc_paths.append(current_osc_path)
        
        while root in pdir.parents or root == pdir.parent:
            file_prepares[pdir.parent].imports.add(pdir.name)
            pdir = pdir.parent

    for path, file_prepare in file_prepares.items():
        path.mkdir(exist_ok=True, parents=True)
        
        init_py = path / '__init__.py'
        with open (init_py, 'w') as f:
            f.write(file_prepare.contents)
        
        if (path.parent.name == 'ray'
                and path.name in ('server', 'session',
                                  'client', 'trashed_client')):
            write_ray_control_pyi(path, file_prepare, path.name)
            if path.name == 'client':
                write_ray_control_pyi(path, file_prepare, 'Client')
